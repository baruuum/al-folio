---
layout: post
title: Trying out Rcpp
date: 2018-12-08 21:52
author: baruuum
comments: true
categories: [R, Rcpp]
---

Now that I've moved my website, I'm considering writting my future posts with `Rmarkdown`. So, this is my first try! I'm thinking of trying out `Rcpp` today, as sometimes `R` is simply too slow. I'm not a big `C/C++` coder, so the code will be kept simple.

So, here's the problem I was dealing with. Suppose you have a `list` object of `length` $15,000$. Each element of this list is again a list of two elements: a matrix of dimension $1,000\times 3$ of individual positions in some space and a matrix of dimension $15\times 3$ of group positions.

We are interested in the angle between any two groups, viewed from the position of each individual. That is, let $\theta$ be the position of individual $i$ in the space $X$ and let $\xi_j, \xi_k$ be the position of group $j$ and $k$. If we subtract $\theta$ from $\xi_i$ and $\xi_j$, we obtain two vectors pointing from $\theta$ towards the two groups. So, the (cosine of the) angle between the two groups, viewed from $i$'s perspective is

$$ \alpha_\theta(\xi_j,\xi_k) = \frac{(\xi_j^\ast)^\top (\xi_k^\ast)}{\|\xi_j^\ast\|\|\xi_j^\ast\|},$$

where $\xi_j^\ast = \xi_j - \theta$ and $\\| \cdot \\|$ is the Euclidean norm. 

If $X$ is a "social" space, this might be a measure of consolidation between two groups viewed from the position at which $i$ finds herself. That is, from the position of $i$ "moving" towards group $j$ means becoming closer to $k$ as well, if the angle between $j$ and $k$ is acute, while it means moving farther away from $k$ if the angle is obtuse. 

To get a population level measure of the consolidation of the groups $j$ and $k$, we might simply take the average of the angles across all individual positions:

$$\phi(\xi_j,\xi_k) = \int_X \alpha_\theta(\xi_j,\xi_k) \text{d}\nu(\theta),$$

where $\nu$ is the distribution of the individuals over the space $X$. 

The problem is estimating $\phi(\xi_j,\xi_k)$. Yet, suppose we have some simulation draws from the joint distribution of $\\{\theta_i^{(s)}, \xi_j^{(s)}, \xi_k^{(s)}\\}_{s=1}^S$. Then we can estimate $\phi$ by 

$$\begin{aligned}
\hat{\phi}(\xi_j,\xi_k) &\approx \frac{1}{S}\sum_{s=1}^S \int_X \alpha_{\theta^{(s)}}(\xi_j^{(s)},\xi_k^{(s)})\text{d}\nu(\theta^{(s)}) \\
&\approx \frac{1}{S}\sum_{s=1}^S \sum_{i=1}^n \alpha_{\theta_i^{(s)}}(\xi_j^{(s)},\xi_k^{(s)}).
\end{aligned}$$

Now, it turns out that this calculation is quite time-consuming, especially if we have $S=15,000$ simulation draws! This is why I considered coding it up in `C++`. 

Let us calculate this first in `R`. But for simplictly, we take the number of simulations to be $S = 50$ and the number of individuals to be $n = 500$. So, here's the data:

{% highlight r %}
set.seed(123)

n.sim <- 50
n <- 500
k <- 15
n.dim <- 4

dat <- lapply(1:n.sim, function(w) {
        list(
            matrix(rnorm(n.dim * n), n, n.dim),
            matrix(rnorm(n.dim * k), k, n.dim)
        )
    })
{% endhighlight %}

To get the simulations of the angles, an `R` coder might use the following:

{% highlight r %}
# centered angle between row/columns of "mat" from the persp of "vec"
r.row.angles <- function(vec, mat) {
    x <- sweep(mat, 2, vec, '-')
    cross <- tcrossprod(x)
    cross / tcrossprod(sqrt(diag(cross)))
}
r.row.angles <- compiler::cmpfun(r.row.angles)

# list of angles
calc.angle.R <- function() lapply(
    dat, function (z) {
        lapply(seq_len(nrow(z[[1]])), function (w) {
            r.row.angles(z[[1]][w,], z[[2]])
        })
    }
)
{% endhighlight %}

Next, let us code the same function in `C++` using the `Rcpp` package. We define the function `row_angles`, which will calculate the angles between the rows of a matrix (group positions, $\xi_j, j=1,2,...,15$) viewed from a point in the same space (individual position, $\theta_i$). Thereafter, we define `row_ind`, which applies `row_angles` to a list of individual and group positions.

{% highlight cpp %}
#include <Rcpp.h>

using namespace Rcpp;

NumericMatrix row_angles(NumericVector xi, NumericMatrix gi) {

    // get object sizes
    int n_i = xi.size();
    int n_g = gi.nrow();
    int dim_space = gi.ncol();
    
    // container for centered vecs, norms, and angles
    NumericMatrix c_vecs(n_g, dim_space);
    NumericVector norms(n_g);
    NumericMatrix out(n_g, n_g);
    
    for (int i = 0; i < n_g; i++) {
    
        // center vectors
        c_vecs(i,_) = gi(i,_) - xi;
    
        // get norm
        double total = 0;
        for (int d = 0; d < dim_space; d++)
            total += pow(c_vecs(i,d), 2.0);
    
        norms(i) = pow(total, 0.5);
    
        // assign 1 to diagonals
        out(i,i) = 1.0;
    
        // calculate angles
        for (int j = 0; j < i; j++) {
    
            double dot_prod = 0;
    
            for (int d = 0; d < dim_space; d++ )
                dot_prod += c_vecs(i,d) * c_vecs(j,d);
    
            out(i,j) = dot_prod / (norms(i) * norms(j));
            out(j,i) = out(i,j);
    
        }

    }

    return out;
    
}

//[[Rcpp::export]]

List ind_angles(List xlist) {
    
    // get ind and group positions
    NumericMatrix xI = xlist(0);
    NumericMatrix gi = xlist(1);
    
    // get object sizes
    int n_i = xI.nrow();
    int n_g = gi.nrow();
    int dim_space = gi.ncol();
    
    // container for results
    List res(n_i);

    for (int n = 0; n < n_i; n++) {
        
        NumericVector xi = xI(n,_);
        res(n) = row_angles(xi, gi);
    
    }
    
    return res;
}
{% endhighlight %}

Once we have saved the `C++` code, we can source it into `R` using the `Rcpp::sourceCpp` function. The great thing about the `Rcpp` package is that it takes care of all the compilation and linking, and wraps the functions so they can be called directly from `R`. One shortcoming is, however, that `Rcpp::sourceCpp` is designed for sourcing single files; so, for more complicated tasks, it is recommended to build packages to handle the interdependencies between several files, including header files.

Now, let's test it out!

{% highlight r %}
library('Rcpp')

# source cpp function into R
sourceCpp('ind_angles.cpp')

# calcualte angles
calc.angle.Cpp <- function() lapply(dat, ind_angles)

# check results
R.res <- calc.angle.R()
Cpp.res <- calc.angle.Cpp()
all.equal(R.res, Cpp.res)
{% endhighlight %}

    ## [1] TRUE

So, in both ways we get the same result. But, was it worth writing the _long_ `C++` code? We might compare the speed of the two codes using the `microbenchmark` package:

{% highlight r %}
library('microbenchmark')
microbenchmark(
    calc.angle.R(),
    calc.angle.Cpp(),
    times = 50
)
{% endhighlight %}

    ## Unit: milliseconds
    ##              expr       min        lq      mean   median       uq       max
    ##    calc.angle.R() 2066.3538 2744.1250 3755.9852 3109.057 4823.354 8870.5290
    ##  calc.angle.Cpp()  112.7488  157.1633  222.1915  182.632  239.312  605.9638
    ##  neval cld
    ##     50   b
    ##     50  a 

The `C++` code is approximately 17 times faster! Of course, we could have tried to write a more efficient `R` code, but there are many situations where this is not possible, e.g., when one calculation depends on the next (think of writing a Gibbs sampler). The `Rcpp` package seems to be the way to go in these situations.
